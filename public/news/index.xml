<?xml version="1.0" encoding="utf-8" standalone="yes" ?>

<feed xmlns="http://www.w3.org/2005/Atom">

  <id>https://addhen.github.io/afam/</id>
  <updated>2016-09-27T11:34:07&#43;09:00</updated>
  <link href="https://addhen.github.io/afam/news/index.xml" rel="self" />
  <category term="" />
  <icon>https://addhen.github.io/afam/images/template/favicon.png</icon>
  <logo>https://addhen.github.io/afam/images/template/logo-512.png</logo>
  <rights>Copyright &#169; AFAM</rights>  
  <title>AFAM</title>
  <subtitle>Website for Addhen Limited. Highlighting its portfolio and service offerings.</subtitle>

  <entry>
    <id>https://addhen.github.io/afam/news/debugging-memory-leaks-in-an-android-app/</id>
    <title>Debugging Memory Leaks In An Android App</title>
    <updated>2016-09-27T11:34:07&#43;09:00</updated>
    <content type="html"><![CDATA[
      

<p>Debugging <strong>memory leaks</strong> in an android app can be a bit tricky. Recently we had to deal with this issue in one of our apps. This was caused due to a recent refactoring we did in our code base. We were holding on to an activity instance that needed to be Garbage Collected<strong>(GC&rsquo;d)</strong> after the activity was destroyed. Yes, you would think the Android Runtime<strong>(ART)</strong> will GC this instance but no. There was another living object in the application that was still holding on to the activity instance so it couldn&rsquo;t be GC&rsquo;d.</p>

<h3 id="investigating-memory-leaks">Investigating Memory Leaks</h3>

<p>Finding out all these information just by reading the codebase can be difficult and time consuming. Luckily there are monitoring tools out there that helps in reporting and investigating <strong>memory leaks</strong>. Android Studio comes with a <a href="https://developer.android.com/studio/profile/am-memory.html">Memory Monitor</a> that essentially monitors memory activities by your app. You can then dump the Java Heap and analyize it for optimizations and possible memory leaks. There is also <a href="https://github.com/square/leakcanary">LeakCanary</a> by the folks at Square. It allows you to integrate memory monitoring directly into your app so it reports any memory leaks in the app.</p>

<p>I&rsquo;m going to share with you the strategy we used in detecting the memory leak in our app, the problematic code and the refactoring we did to eliminate the issue.</p>

<h4 id="1-used-leakcanary-to-detect-memory-leaks-in-the-app">1. Used LeakCanary To Detect Memory Leaks In the App</h4>

<p>In our app&rsquo;s <code>devel flavor</code>, we have LeakCanary enabled. This is a practice we do with all of our apps as it makes it easier to detect and fix memory leaks as we develop. With our devel build variant launched in an emulator, we used it like a regular user will use the app. We fetched the needed content, scrolled through them and nothing really happened. The issue showed up just when we rotated the emulator to change screen orientation, after few seconds, LeakCanary reported a memory leak, followed by a dump of our app&rsquo;s heap. LeakCanary displays the heap in an optimized way so it&rsquo;s easier to find which dominant object is still referencing an object that needs to be GC&rsquo;d.</p>

<h4 id="2-enabled-profiling-to-monitor-memory-activities">2. Enabled Profiling To Monitor Memory Activities</h4>

<p>Once we have detected a memory leak in our app, we enabled Memory Monitor to see the allocation and deallocations of memories in our apps. Also we forced excessive GC to see which objects are GC&rsquo;d or not.</p>

<h4 id="3-dumped-java-heap-and-analyzed-the-trace">3. Dumped Java Heap And Analyzed The Trace.</h4>

<p>After we have run the profiler for a while, we took a heap dump of it. Using the inbuilt <a href="https://developer.android.com/studio/profile/investigate-ram.html">HPROF Viewer</a> in Android studio, we&rsquo;ere able to analyze the trace for all possible memory leaks in the app. Indeed after analyzing it, we had one issue of memory leak. We were able to jump into the source code to see which code is causing the issue.</p>

<h4 id="4-located-defected-code">4. Located Defected Code</h4>

<p>This leaks an Activity.</p>


<pre class="prettyprint linenums"><code class="language-java">public class Launcher {
    // This will be strongly held by the instance of the Launcher class.
    private Activity mActivity;

    @Inject
    public Launcher(Activity activity) {
        mActivity = activity;
    }

    public void launchReviewList(Context context, Long movieId) {
        context.startActivity(ListReviewsActivity.getIntent(context, movieId));
    }
    
    // This is bad code
    public void launchMovieDetails(FragmentActivity activity, Long movieId, View view) {
        ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(
                // The context of the activity
                activity,
                Pair.create(view, activity.getString(R.string.transition_movie_details)),
                Pair.create(view, activity.getString(R.string.transition_movie_details_background))
        );
        ActivityCompat.startActivity(activity, DetailMovieActivity.getIntent(mActivity, movieId),
                options.toBundle());
    }

    public void launchReminders(Context context) {
        context.startActivity(ListRemindersActivity.getIntent(context));
    }
}

</code></pre>



<p>The dominant object, <code>mLauncher</code> was holding on to the instance of the activity class.</p>


<pre class="prettyprint linenums"><code class="language-java">
public class ListMovieFragment extends BaseRecyclerViewFragment&lt;MovieModel, MovieAdapter&gt; implements
        MovieListView, RecyclerViewItemTouchListenerAdapter.RecyclerViewOnItemClickListener,
        OnLoadMoreListener, SwipeRefreshLayout.OnRefreshListener {

    @BindView(R.id.loading_list)
    ProgressBar mProgressBar;

    @BindView(android.R.id.empty)
    View mEmptyView;

    @Inject
    ListMoviePresenter mListMoviePresenter;

    @Inject
    Launcher mLauncher;

    private boolean mIsPaginating;

    private boolean isFromInternet;

    public ListMovieFragment() {
        super(MovieAdapter.class, R.layout.fragment_movie_list, 0);
    }
    ...
}
</code></pre>



<p>An instance of <code>Launcher</code> class, <code>mLauncher</code> is declared in the <code>ListMovieFragment</code> class and it&rsquo;s referencing an instance of the <code>MainActivity</code> which is declared in the <code>Launcher</code> class as <code>mActivity</code>. Because the fragment class still exist after the main activity hosting it is destroyed.</p>

<h4 id="5-refactored-defected-code-to-eliminate-the-issue">5. Refactored Defected Code To Eliminate The Issue</h4>


<pre class="prettyprint linenums"><code class="language-java">
public class Launcher {

    @Inject
    public Launcher() {
    }

    public void launchReviewList(Context context, Long movieId) {
        context.startActivity(ListReviewsActivity.getIntent(context, movieId));
    }

    public void launchMovieDetails(Activity activity, Long movieId, View view) {
        ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(
                // The context of the activity
                activity,
                Pair.create(view, activity.getString(R.string.transition_movie_details)),
                Pair.create(view, activity.getString(R.string.transition_movie_details_background))
        );
        ActivityCompat.startActivity(activity, DetailMovieActivity.getIntent(activity, movieId),
                options.toBundle());
    }

    public void launchReminders(Context context) {
        context.startActivity(ListRemindersActivity.getIntent(context));
    }
}

</code></pre>



<p>We removed the global instance of Activity, <code>mActivity</code> and instead passed it as a parameter to the method that needed it. This way it can be <code>GC'd</code> easily as there is no strong hold of it anymore.</p>

<h3 id="conclusion">Conclusion</h3>

<p>If you&rsquo;re curious about memory leaks in general and ways to avoid them, you can read these great articles belows.</p>

<ol>
<li><a href="http://blog.nimbledroid.com/2016/09/06/stop-memory-leaks.html">Eight Ways Your Android App Can STOP Leaking memory</a></li>
<li><a href="https://developer.android.com/studio/profile/am-memory.html">Memory Monitor</a></li>
<li><a href="https://developer.android.com/studio/profile/am-hprof.html#hprof-diving">HPROF Viewer and Analyzer</a></li>
<li><a href="https://developer.android.com/studio/profile/investigate-ram.html">Investigating Your RAM Usage</a></li>
<li><a href="https://www.youtube.com/watch?v=mU1VcKx8Wzw">Detect all memory leaks with LeakCanary! - Youtube Link</a></li>
</ol>

    ]]></content>
    <link rel="alternate" href="https://addhen.github.io/afam/news/debugging-memory-leaks-in-an-android-app/" />
  </entry>
  <entry>
    <id>https://addhen.github.io/afam/news/persisting-with-cupboard/</id>
    <title>Persisting Data Objects With Cupboard</title>
    <updated>2016-06-27T09:50:18&#43;09:00</updated>
    <content type="html"><![CDATA[
      <p>There are serveral contenders when it comes to persisting data on Android.
At addhen, our favourite is <a href="https://bitbucket.org/littlerobots/cupboard/wiki/Home">cupboard</a>. It&rsquo;s a lightweight data storage for Android. At first, it seems like an <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a> but it isn&rsquo;t, as it doesn&rsquo;t manage table relationships and all that fancy features that comes with it. It gives you a neat API to store and retrieve data objects on Android.</p>

<p>We structure our database tables around the <code>JSON</code> response we get from API calls. At times we&rsquo;re tempted to create tables just to conform to the structure of the <code>JSON</code> string. Hence sometimes we wished <code>cupboard</code> could manage table relationships. But it does give you the flexibility to do all of that. It just means you will have to write a bit of code to achieve that.</p>

<p>In most cases when we look at the structure of our <code>JSON</code> string, we look for ways to elimenate the need to create extra tables. To achieve that, we try to store some part of the <code>JSON</code> string in it serialized format. Then deserialize it upon retrieval. Cupboard provides you with the necessary mechanism to acheive all that. We&rsquo;re going to share with you how we approach this.</p>

<p>So let&rsquo;s say we have this <code>JSON</code> string</p>


<pre class="prettyprint linenums"><code class="language-java">[
  {
    &#34;id&#34;: 1,
    &#34;name&#34;: &#34;Apples&#34;,
    &#34;price&#34;: 10,
    &#34;note&#34;: &#34;I usually buy them from the convenient store.&#34;,
    &#34;expiry_date&#34;: &#34;28-07-2017&#34;,
    &#34;category&#34;: {
      &#34;id&#34;: 9,
      &#34;url&#34;: &#34;http://www.api.data.com/categories/9&#34;
    },
    &#34;quantity&#34;: {
      &#34;initial&#34;: &#34;10&#34;,
      &#34;remaining&#34;: &#34;5&#34;,
      &#34;unit&#34;: &#34;None&#34;,
      &#34;reorder&#34;: 3
    }
  },
  {
    &#34;id&#34;: 2,
    &#34;name&#34;: &#34;Arugula&#34;,
    &#34;price&#34;: 200,
    &#34;note&#34;: &#34;I got them from the amazon jp store&#34;,
    &#34;expiry_date&#34;: &#34;16-07-2018&#34;,
    &#34;category&#34;: {
      &#34;id&#34;: 9,
      &#34;url&#34;: &#34;http://www.api.data.com/categories/9&#34;
    },
    &#34;quantity&#34;: {
      &#34;initial&#34;: &#34;6&#34;,
      &#34;remaining&#34;: &#34;2&#34;,
      &#34;unit&#34;: &#34;box&#34;,
      &#34;reorder&#34;: 3
    }
  }
]
</code></pre>



<p>The <a href="https://en.wikipedia.org/wiki/Plain_Old_Java_Object">POJO</a> for this will be</p>


<pre class="prettyprint linenums"><code class="language-java">public class InventoryEntity extends Data {

    public String name;

    public float price;

    public String note;

    public CategoryEntity category;

    public Quantity quantity;

    public Date expiryDate;

    public InventoryEntity() {
        // Do nothing
    }

    public InventoryEntity(Long id, String name, float price, Quantity quantity,
            String note, CategoryEntity category, Date expiryDate) {
        this._id = id;
        this.name = name;
        this.price = price;
        this.quantity = quantity;
        this.note = note;
        this.category = category;
        this.expiryDate = (Date) expiryDate.clone();
    }

    public static class Quantity {

        public int initial;

        public int remaining;

        public int reorder;

        public String unit;

        public Quantity(int initial, int remaining, int reorder, String unit) {
            this.initial = initial;
            this.remaining = remaining;
            this.reorder = reorder;
            this.unit = unit;
        }
    }
}
</code></pre>



<p>Since <code>cupboard</code> stores objects into the database, this <code>POJO</code> should just work right? But no, it doesn&rsquo;t. It wouldn&rsquo;t know how to handle the <code>Quantity</code> property as it&rsquo;s a subclass. In a regular database relationship, you could create a table to hold the <code>Quantity</code> class but you can eliminate that, if you could just store that part as a <code>JSON</code> string. This alleviates the pain of managing table relationships.</p>

<p>We utilize cupboard&rsquo;s converters to achieve that. In that when saving the object, we intercept the process and keep the <code>Quantity</code> property in this case, as a regular <code>JSON</code> string. We create a custom <code>FieldConverter</code> and use it to check if cupboard is about to process the <code>Quantity</code> field, then save the <code>JSON</code> string instead of the deserialized format.</p>

<p>First, create a generic field converter using <code>GSON</code></p>


<pre class="prettyprint linenums"><code class="language-java">public class GsonFieldConverter&lt;T&gt; implements FieldConverter&lt;T&gt; {

    private final Gson mGson;

    private final Type mType;

    public GsonFieldConverter(Gson gson, Type type) {
        mGson = gson;
        mType = type;
    }

    @Override
    public T fromCursorValue(Cursor cursor, int columnIndex) {
    	  // Convert from JSON string to POJO
        return mGson.fromJson(cursor.getString(columnIndex), mType);
    }

    @Override
    public void toContentValue(T value, String key, ContentValues values) {
    	 // Convert from POJO to JSON string
        values.put(key, mGson.toJson(value));
    }

    @Override
    public EntityConverter.ColumnType getColumnType() {
        return EntityConverter.ColumnType.TEXT;
    }
}
</code></pre>



<p>Second, by some <a href="https://docs.oracle.com/javase/tutorial/reflect/">Reflection</a> magic, cupboard allows you to figure out which field it&rsquo;s processing, allowing you to process that field before it stores or retrieves it from the database.</p>


<pre class="prettyprint linenums"><code class="language-java">public class InventoryEntityConverterFactory extends ReflectiveEntityConverter&lt;InventoryEntity&gt; {

    /**
     * Default constructor
     *
     * @param cupboard The {@link Cupboard} object
     */
    public InventoryEntityConverterFactory(Cupboard cupboard) {
        super(cupboard, InventoryEntity.class);
    }

    @Override
    protected FieldConverter&lt;?&gt; getFieldConverter(Field field) {
        if (&#34;quantity&#34;.equals(field.getName())) {
        	  // Use the field converter to deserilize/serialize the quantity field
            return new GsonFieldConverter&lt;&gt;(new Gson(),
                    new TypeToken&lt;InventoryEntity.Quantity&gt;() {
                    }.getType());
        }
        return super.getFieldConverter(field);
    }
}  
</code></pre>



<p>Third, we have to initialize this when registering the entities with cupboard otherwise all this implementation won&rsquo;t make any sense to it.</p>


<pre class="prettyprint linenums"><code class="language-java">private static final Class[] ENTITIES = new Class[]{
    InventoryEntity.class, CategoryEntity.class,
};

static {
    EntityConverterFactory factory = new EntityConverterFactory() {

        @Override
        public &lt;T&gt; EntityConverter&lt;T&gt; create(Cupboard cupboard, Class&lt;T&gt; type) {
            if (type == InventoryEntity.class) {
                return (EntityConverter&lt;T&gt;) new InventoryEntityConverterFactory(cupboard);
             }
             return null;
        }
    };

    CupboardFactory.setCupboard(new CupboardBuilder()
                .registerEntityConverterFactory(factory).useAnnotations().build());
    // Register our entities
    for (Class&lt;?&gt; clazz : ENTITIES) {
        cupboard().register(clazz);
    }
}
</code></pre>



<p>To learn more about cupboard, check its <a href="https://bitbucket.org/littlerobots/cupboard/wiki/Home">wiki</a>. It has lots of how-tos to get you started.</p>

    ]]></content>
    <link rel="alternate" href="https://addhen.github.io/afam/news/persisting-with-cupboard/" />
  </entry>
  <entry>
    <id>https://addhen.github.io/afam/news/internationalization-and-localization-on-android/</id>
    <title>Best Practices For Supporting Internationalization and Localization On Android</title>
    <updated>2016-06-01T11:08:17&#43;09:00</updated>
    <content type="html"><![CDATA[
      <p>At addhen, localization is something we take very seriously when developing an Android application. Though most of our apps aren&rsquo;t translated into most languages, we make sure we build apps that are localizable. That way in the future when we&rsquo;re ready to open the app to more regions and languages, we already have a strong foundation. I&rsquo;m going to share some of our best practices for localization support.  If you&rsquo;re not familiar with what <em>internationalization</em> and <em>localization</em> are, I&rsquo;ll go ahead to define them.</p>

<p><strong>Internationalization</strong> is the process of designing an application to make it possible for it to be localized to a particular region and language.</p>

<p><strong>Localization</strong> is the act of making a product suited for a particular region and language that conforms to the region&rsquo;s <em>locale</em>.</p>

<p><strong>Locale</strong> is a set of parameters that defines the user&rsquo;s language and region.</p>

<ol>
<li><p><strong>Never hardcode user facing strings</strong></p>

<p>At all cost we avoid hardcoding all static strings the user would have to see. We make sure we have them in their respective string resource file. For example,</p>

<p><code>mLableTextView.setText(&quot;Quantity&quot;);</code> This makes it hard to replace in the future when we want to translate <code>Quantity</code> into more languages. Instead we put that in a string resource and reference the name when setting the TextView&rsquo;s text. In <code>res/values/string.xml</code> we&rsquo;ll have</p>

<p><code>&lt;string name=&quot;quantity&quot;&gt;Quantity&lt;/string&gt;</code></p>

<p>Then reference it in code as <code>mLableTextView.setText(R.string.quantity);</code> using the string name. This way, when we want to translate <code>Quantity</code> into French we&rsquo;ll have to put it in <code>res/values-fr/string.xml</code> where <code>-fr</code> is the resource qualifer for the French language.</p></li>

<li><p><strong>Load fonts as localized string</strong></p>

<p>When we make use of custom fonts, we don&rsquo;t hardcode that either in the view. This makes it possible for us to easily support fonts for a particular language. In the same way as we define string, we put the font name in a string resource file.</p>

<p><code>&lt;string name=&quot;custom_font_name&quot;&gt;fonts/custom_font.ttf&lt;/string&gt;</code></p>

<p>Then declare a styleable attribute that can be referenced in the View&rsquo;s implementation. This also makes it possible to set the font in a layout resource file.</p>


<pre class="prettyprint linenums"><code class="language-xml">
    &lt;!-- Inside res/values/attrs.xml --&gt;
    &lt;declare-styleable name=&#34;CustomView&#34;&gt;
        &lt;attr name=&#34;fontName&#34; format=&#34;String&#34;/&gt;
    &lt;/declare-styleable&gt;
    </code></pre>



<p>In our custom view implementation, we load and cache the font in memory. See sample code below.</p>


<pre class="prettyprint linenums"><code class="language-java">
    public CustomView(Context context, AttributeSet attributeSet) {
        super(context, attributeSet);
        initCustomFont(context, attributeSet);
    }

    private void initCustomFont(Context context, AttributeSet attributeSet) {
        final TypedArray attrs = context.obtainStyledAttributes(attributeSet, R.styleable.CustomView);
        final String fontName = attrs.getString(R.string.CustomView_fontName);
        final TypefaceManager typefaceManager = new TypefaceManager();
        final Typeface typeface = typefaceManager.getTypeface(context,fontName);
        if (typeface != null) {
            super.setTypeface(typeface);
        }
    }
    
    // Manages loading and caching of the font
    private static class TypefaceManager {

        private final LruCache&lt;String, Typeface&gt; mCache;

        public TypefaceManager() {
            mCache = new LruCache&lt;&gt;(3);
        }

        public Typeface getTypeface(final Contenxt context, final String filename) {
            Typeface typeface = mCache.get(filename);
            if (typeface == null) {
                typeface = Typeface.createFromAsset(context.getAssets(), filename);
                mCache.put(filename, typeface);
            }
            return typeface;
        }
    }
    </code></pre>



<p>In our xml <code>res/layout/label_item.xml</code> we then set the font as shown below.</p>


<pre class="prettyprint linenums"><code class="language-xml">
    &lt;com.package.name.widget.CustomView
        ...
        app:fontName=&#34;@string/custom_font_name&#34;/&gt;
    </code></pre>

</li>

<li><p><strong>Right-To-Left (RTL) support enabled</strong></p>

<p>We enable <code>RTL</code> since it doesn&rsquo;t really require much work. It makes our layouts ready for switching to an <code>RTL</code> language. In
the application manifest, we enable layout mirroring by setting <code>android:supportsRtl</code> to <code>true</code>.

<pre class="prettyprint linenums"><code class="language-xml">
    &lt;application
        ...
        android:supportsRtl=&#34;true&#34;/&gt;
    </code></pre>

</p>

<p>If we&rsquo;re targing <code>API 17</code> and above, we replace all <code>left/right</code> layout properties to the new <code>start/end</code> equivalents. So <code>paddingLeft</code> becomes <code>paddingStart</code> and <code>paddingRight</code> becomes <code>paddingEnd</code>. Same for margin directional properties. It requires a bit of work when targeting below <code>API 17</code>. Instead of supporting different layouts which makes maintenance a headache, we put these properties in a style resource for the different API versions. See sample code below.

<pre class="prettyprint linenums"><code class="language-xml">
    &lt;!-- res/values-v17/styles.xml targets API level 17&#43; --&gt;
    &lt;style name=&#34;TextView.Label&#34;&gt;
        ...
        &lt;item name=&#34;android:layout_marginStart&#34;&gt;16dp&lt;/item&gt;
        &lt;item name=&#34;android:layout_marginEnd&#34;&gt;16dp&lt;/item&gt;
        ...
    &lt;/style&gt;

    &lt;!-- res/values/styles.xml targets API 17- --&gt;
    &lt;style name=&#34;TextView.Label&#34;&gt;
        ...
        &lt;item name=&#34;android:layout_marginLeft&#34;&gt;16dp&lt;/item&gt;
        &lt;item name=&#34;android:layout_marginRight&#34;&gt;16dp&lt;/item&gt;
        ...
    &lt;/style&gt;

    &lt;!-- res/layout/screen_layout.xml --&gt;
    &lt;com.package.name.widget.CustomView
        style=&#34;@style/TextView.Label&#34;
        android:layout_width=&#34;wrap_content&#34;
        android:layout_height=&#34;wrap_content&#34;
        app:fontName=&#34;@string/custom_font_name&#34;/&gt;
    </code></pre>

</p></li>

<li><p><strong>Localize line heights dimensions</strong></p>

<p>At all cost we don&rsquo;t hardcode value for the <code>android:lineSpacingMultiplier</code> property. This way, it&rsquo;s easier to localize line heights value. Some langagues will need bigger line spacing than others.</p>


<pre class="prettyprint linenums"><code class="language-xml">
    &lt;!-- res/values/integers.xml --&gt;
    &lt;resources&gt;
        &lt;item name=&#34;line_height&#34; format=&#34;float&#34; type=&#34;integer&#34;&gt;0.5&lt;/item&gt;
    &lt;/resources&gt;

    &lt;!-- res/values-fr/integers.xml --&gt;
    &lt;style name=&#34;TextView.Label&#34;&gt;
        &lt;item name=&#34;line_height&#34; format=&#34;float&#34; type=&#34;integer&#34;&gt;1.0&lt;/item&gt;
    &lt;/style&gt;

    &lt;!-- res/layout/screen_layout.xml --&gt;
    &lt;com.package.name.widget.CustomView
        style=&#34;@style/TextView.Label&#34;
        android:layout_width=&#34;wrap_content&#34;
        android:layout_height=&#34;wrap_content&#34;
        android:lineSpacingMultiplier=&#34;@integer/line_height&#34;
        app:fontName=&#34;@string/custom_font_name&#34;/&gt;
    </code></pre>

</li>

<li><p><strong>Test using pseudolocalization</strong></p>

<p>Since most of our apps aren&rsquo;t translated into different languages, we take advantage of pseudo-localization provided by Android. Pseudo-localization in general is a method of testing the internationalization of text while maintaining its readability. We do this more to expose issues regarding length and flow of text and layout issues. In our debug builds, we enable pseudolocalization by setting <code>pseudoLocalesEnabled</code> to <code>true</code></p>


<pre class="prettyprint linenums"><code class="language-java">
    // In build.gradle file
    buildTypes {
        debug {
            pseudoLocalesEnabled true
        }
    }
    </code></pre>



<p>Then configure a device to make use of the <code>en_XA</code> locale. This gives us texts which are longer and with accents. And to test the layout mirroring (RTL), we configure the device to another locale <code>ar_XB</code>. This shifts everything from <code>Left-Right</code> to <code>Right-Left</code>.</p>

<p>On a compatible Android device go to settings and select <strong>Language &amp; Input</strong> &gt; <strong>Language</strong> &gt; <strong>English (XA)</strong> to enable the <code>en_XA</code> locale.</p>

<p>Go to settings and select <strong>Language &amp; Input</strong> &gt; <strong>Language</strong> &gt; <strong>(XB) العربية</strong> to enable the <code>ar_XB</code> locale.</p></li>
</ol>

<p>As good practice, we make sure before we make a final release to the Playstore, we&rsquo;ve tested our apps in at least 3 or more different languages to visually inspect how the app will behave in these langagues. Though this gives us extra workload it makes us confident that, our app doesn&rsquo;t only function well but it&rsquo;s appears good in other languages.</p>

<p>The android documentation has a <a href="https://developer.android.com/distribute/tools/localization-checklist.html">checklist</a> for localization that you can go through to make your app localizable which I recommend reading.</p>

    ]]></content>
    <link rel="alternate" href="https://addhen.github.io/afam/news/internationalization-and-localization-on-android/" />
  </entry>
  <entry>
    <id>https://addhen.github.io/afam/news/storing-objects-with-shared-preferences/</id>
    <title>Storing Objects With Shared Preferences</title>
    <updated>2016-05-16T14:02:21&#43;09:00</updated>
    <content type="html"><![CDATA[
      <p>As you know <a href="http://developer.android.com/reference/android/content/SharedPreferences.html">SharedPreferences</a> allows you to store key-value pairs of primitive data types in an XML and provides you with a decent API for storing/retrieving their values. It&rsquo;s mostly used to persist values from Preferences/Settings screens.</p>

<p>In a recent project, we wanted to make use of the <strong>Shared Preferences</strong> framework to store an object&rsquo;s properties more so for convenience. Usually we&rsquo;ll store these in an SQLite database but with this use case we thought it was an overkill to do that. Instead, we leveraged on <strong>JSON</strong> and the <a href="http://developer.android.com/reference/android/content/SharedPreferences.html">SharedPreferences</a> class.</p>

<p>The design in it basic form: We serialize the object into a JSON string upon storing it and then store the regular string. Upon retrieving it, we deserialize the JSON string back into the object. Mind you this operation can be costly when the object being operated on has huge properties. So if you&rsquo;re planning on using this technique for large objects, it would be better to make use of the other storage options provided by the Android framework.</p>

<p>The design in it detailed form: We designed a simpile persistent storage with <a href="https://github.com/google/gson">GSON</a>, the underlining serialization mechanisim and <a href="http://developer.android.com/guide/topics/data/data-storage.html#pref">Shared Preferences</a>, the storage engine. We made it in such a way that you can use which ever storage or serialization engine you prefer.</p>

<p>We provided two interfaces, one for the Serialization mechanism and another for the Storage engine. To share some code, here is the interface for implementing the serialization mechanism.</p>


<pre class="prettyprint linenums"><code class="language-java">public interface SerializationMechanism&lt;T&gt; {

    /**
     * Serializes a T to a JSON string
     *
     * @param entity The type entity to be serialized
     * @return String The serialized object into a JSON string
     */
    String serialize(T entity);

    /**
     * Deserializes a JSON string to it&#39;s typed entity
     *
     * @param serializedEntity The serialized object in a JSON format
     * @return A type entity
     */
    T deserialize(String serializedEntity);
}
</code></pre>



<p>And the interface for the storage engine.</p>


<pre class="prettyprint linenums"><code class="language-java">
public interface StorageMechanism&lt;T&gt; {

    /**
     * Gets an {@link rx.Observable} which will emit a list of {@link EntityType}.
     */
    Observable&lt;List&lt;EntityType&gt;&gt; get();

    /**
     * Gets an {@link rx.Observable} which will emit a {@link EntityType}.
     */
    Observable&lt;EntityType&gt; get(String key);

    /**
     * Puts an element into storage
     *
     * @param The unique key to identify this entity type
     * @param entityType Element to insert into storage.
     *
     * @return  The stored entity type
     */
    Observable&lt;EntityType&gt; put(String key, EntityType entityType);

    /**
     * Deletes a particular entity type
     */
    Observable&lt;Boolean&gt; delete(String key);

    /**
     * Delete all persisted elements
     */
    Observable&lt;Boolean&gt; deleteAll();
}
</code></pre>



<p>Now let&rsquo;s look at their respective implementations.</p>

<p>The serialization mechanism:</p>


<pre class="prettyprint linenums"><code class="language-java">public class GsonSerializationMechanism implements SerializationMechanism&lt;EntityType&gt; {

    private final Gson mGson = new Gson();

    private final Type mTypeToken = new TypeToken&lt;List&lt;EntityType&gt;&gt;() {}.getType();

    public String serialize(EntityType entityType) {
        return mGson.toJson(entityType, mTypeToken);
    }
    
    public EntityType deserialize(String jsonString) {
        return mGson.fromJson(jsonString, mTypeToken);
    }
}
</code></pre>



<p>The storage mechanism implementation: This is a <a href="https://github.com/ReactiveX/RxJava">RxJava</a> based implementation. You will noticed most of the functions are returning an Observable. You can do away with the RxJava implementation if you don&rsquo;t
find that useful for your use case.</p>


<pre class="prettyprint linenums"><code class="language-java">public class SharedPreferenceStorageMechanism implements StorageMechanism&lt;EntityType&gt; {

    private final SharedPreferences mSharedPreferences;

    private final SerializationMechanism mSerializationMechanism;

    public SharedPreferenceStorageMechanism(SharedPreferences sharedPreferences, 
        StorageMechanism serializationMechanism) {
        mSharedPreferences = sharedPreferences;
        mSerializationMechanism = serializationMechanism;
    }

    @Override
    public Observable&lt;EntityType&gt; put(@NonNull String key, @NonNull EntityType entityType) {
        return Observable.create(subscriber -&gt; {
            mSharedPreferences.edit().putString(key,mSerializationStrategy.serialize(entityType)).apply();
            subscriber.onNext(entityType);
            subscriber.onCompleted();
        });
    }

    @Override
    public Observable&lt;Boolean&gt; delete(@NonNull String key) {
        return Observable.defer(() -&gt; {
        if (TextUtils.isEmpty(key)) {
            return Observable.just(Boolean.FALSE);
        }
        mSharedPreferences.edit().remove(key).apply();
            return Observable.just(Boolean.TRUE);
       });
    }

    @Override
    public Observable&lt;Boolean&gt; deleteAll() {
        return Observable.defer(() -&gt; {
            mSharedPreferences.edit().clear().apply();
            return Observable.just(Boolean.TRUE);
        });
    }

    @Override
    public Observable&lt;List&lt;EntityType&gt;&gt; get() {
        return Observable.create(subscriber -&gt; {
            Map&lt;String, String&gt; savedTypes = (Map&lt;String, String&gt;) mSharedPreferences
                    .getAll();
            List&lt;EntityType&gt; entitiesTypes = new ArrayList&lt;EntityType&gt;();
            for (Map.Entry entry : savedTypes.entrySet()) {
                entitiesTypes.add(mSerializationStrategy.deserialize((String) entry.getValue()));
            }
            subscriber.onNext(entitiesTypes);
            subscriber.onCompleted();
        });
    }

    @Override
    public Observable&lt;EntityType&gt; get(String key) {
        return Observable.create(subscriber -&gt; {
            EntityType entityType = getStored(key);
            if (entityType != null) {
                subscriber.onNext(entityType);
                subscriber.onCompleted();
            } else {
                subscriber.onError(new NotFoundException());
            }
        });
    }

    private EntityType getStored(String key) {
        final String jsonString = mSharedPreferences.getString(key, null);
        return mSerializationStrategy.deserialize(jsonString);
    }
}
</code></pre>



<p>This so far has been working greatly in our current use case. Hope you will find this useful in your projects.</p>

    ]]></content>
    <link rel="alternate" href="https://addhen.github.io/afam/news/storing-objects-with-shared-preferences/" />
  </entry>
  <entry>
    <id>https://addhen.github.io/afam/news/welcome/</id>
    <title>Welcome To Our Blog</title>
    <updated>2016-02-19T20:35:29&#43;00:00</updated>
    <content type="html"><![CDATA[
      <p>First of all thank you for dropping by on our blog. This is our first blog post as a company specialized in Android apps development. We will mostly be blogging about the projects we&rsquo;re working on and the overall well being of the company. Most content here will quite be technical as we will be sharing our experiences as we work on projects. Also we will be writing a lot of updates related to the Android platform.</p>

<p>If you are interested in Android developments, feel free to bookmark this blog and check back frequently for content on Android development.</p>

    ]]></content>
    <link rel="alternate" href="https://addhen.github.io/afam/news/welcome/" />
  </entry>
</feed>