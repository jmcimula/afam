<!doctype html><!--[if lt IE 7]> <html class="ie6" lang="ja" prefix="og: http://ogp.me/ns#"> <![endif]--><!--[if IE 7]> <html class="i7" lang="ja" prefix="og: http://ogp.me/ns#"> <![endif]--><!--[if IE 8]> <html class="ie" lang="ja" prefix="og: http://ogp.me/ns#"> <![endif]--> <!--[if gt IE 8]><!--><!--<![endif]--><html lang="en-US" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta property="og:title" content="Debugging Memory Leaks In An Android App"><meta property="og:description" content="Debugging memory leaks in an android app can be a bit tricky. Recently we had to deal with this issue in one of our apps. This was caused due to a recent refactoring we did in our code base. We were holding on to an activity instance that needed to be Garbage Collected(GC&rsquo;d) after the activity was destroyed. Yes, you would think the Android Runtime(ART) will GC this instance but no."><meta property="og:type" content="website"><meta property="og:url" content="https://addhen.github.io/afam/news/debugging-memory-leaks-in-an-android-app/"><meta property="og:updated_time" content="2016-09-27 11:34:07 &#43;0900 JST"><meta itemprop="name" content="Debugging Memory Leaks In An Android App"><meta itemprop="description" content="Debugging memory leaks in an android app can be a bit tricky. Recently we had to deal with this issue in one of our apps. This was caused due to a recent refactoring we did in our code base. We were holding on to an activity instance that needed to be Garbage Collected(GC&rsquo;d) after the activity was destroyed. Yes, you would think the Android Runtime(ART) will GC this instance but no."><meta itemprop="keywords" content="accessibility,database,debugging,leakcanary,localization,memory-leaks,profiling,sharing,storing,translation,"><meta itemprop="wordCount" content="805"><meta name="news_keywords" content="debugging,memory leaks,profiling,Android,leakcanary"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Debugging Memory Leaks In An Android App"><meta name="twitter:description" content="Debugging memory leaks in an android app can be a bit tricky. Recently we had to deal with this issue in one of our apps. This was caused due to a recent refactoring we did in our code base. We were holding on to an activity instance that needed to be Garbage Collected(GC&rsquo;d) after the activity was destroyed. Yes, you would think the Android Runtime(ART) will GC this instance but no."><meta name="twitter:site" content="@afam"><meta name="twitter:domain" content="www.afam.com"><title>AFAM &mdash; Debugging Memory Leaks In An Android App</title><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.0/css/font-awesome.min.css" rel="stylesheet" type="text/css" media="all"><link rel="stylesheet" href="https://addhen.github.io/afam/css/bootstrap.min.css" media="screen"><link href="https://fonts.googleapis.com/css?family=Lato|Open+Sans|Roboto+Condensed|Roboto+Mono|Roboto+Slab|Orbitron:400,500,700,900" rel="stylesheet"><link href="https://addhen.github.io/afam/css/mdb.min.css" rel="stylesheet" media="all" type="text/css"><link href="https://addhen.github.io/afam/css/styles-8609750943.min.css" rel="stylesheet" media="all" type="text/css"><link href="" rel="alternate" type="application/rss+xml" title="AFAM"></head><body><header><nav class="navbar navbar-dark navbar-fixed-top scrolling-navbar danger-color-dark"><button class="navbar-toggler hidden-sm-up" type="button" data-toggle="collapse" data-target="#collapseEx"><i class="fa fa-bars"></i></button><div class="container"><div class="collapse navbar-toggleable-xs" id="collapseEx"><div id="logo"><a class="waves-effect waves-light navbar-brand" href="https://addhen.github.io/afam/">AFAM</a></div><ul class="nav navbar-nav smooth-scroll"><li class="nav-item"><a class="nav-link" href="https://addhen.github.io/afam/">Home</a></li><li class="nav-item"><a class="nav-link" href="https://addhen.github.io/afam/calendar">Calendar</a></li><li class="nav-item"><a class="nav-link" href="https://addhen.github.io/afam/join/">Join</a></li><li class="nav-item page-scroll"><a class="nav-link page-scroll" href="https://addhen.github.io/afam/#contact">Contact Us</a></li></ul><ul class="nav navbar-nav nav-flex-icons"><li class="nav-item"><a class="nav-link"><i class="fa fa-facebook"></i></a></li><li class="nav-item"><a class="nav-link"><i class="fa fa-twitter"></i></a></li><li class="nav-item"><a class="nav-link"><i class="fa fa-instagram"></i></a></li></ul></div></div></nav></header><div class="container"><div class="row"><div class="wrap-content col-md-10 offset-md-1"><h2>Debugging Memory Leaks In An Android App</h2><ul class="list-inline"><li class="list-inline-item"><span class="post-meta"><i class="fa fa-calendar"></i> <time datetime="2016-09-27T11:34:07&#43;09:00" itemprop="datePublished">September 27, 2016</time></span></li><li class="list-inline-item"><span class="post-meta"><i class="fa fa-user"></i> Henry Addo</span></li></ul><div class="row"><div class="p-l-1"><p>Debugging <strong>memory leaks</strong> in an android app can be a bit tricky. Recently we had to deal with this issue in one of our apps. This was caused due to a recent refactoring we did in our code base. We were holding on to an activity instance that needed to be Garbage Collected<strong>(GC&rsquo;d)</strong> after the activity was destroyed. Yes, you would think the Android Runtime<strong>(ART)</strong> will GC this instance but no. There was another living object in the application that was still holding on to the activity instance so it couldn&rsquo;t be GC&rsquo;d.</p><h3 id="investigating-memory-leaks">Investigating Memory Leaks</h3><p>Finding out all these information just by reading the codebase can be difficult and time consuming. Luckily there are monitoring tools out there that helps in reporting and investigating <strong>memory leaks</strong>. Android Studio comes with a <a href="https://developer.android.com/studio/profile/am-memory.html">Memory Monitor</a> that essentially monitors memory activities by your app. You can then dump the Java Heap and analyize it for optimizations and possible memory leaks. There is also <a href="https://github.com/square/leakcanary">LeakCanary</a> by the folks at Square. It allows you to integrate memory monitoring directly into your app so it reports any memory leaks in the app.</p><p>I&rsquo;m going to share with you the strategy we used in detecting the memory leak in our app, the problematic code and the refactoring we did to eliminate the issue.</p><h4 id="1-used-leakcanary-to-detect-memory-leaks-in-the-app">1. Used LeakCanary To Detect Memory Leaks In the App</h4><p>In our app&rsquo;s <code>devel flavor</code>, we have LeakCanary enabled. This is a practice we do with all of our apps as it makes it easier to detect and fix memory leaks as we develop. With our devel build variant launched in an emulator, we used it like a regular user will use the app. We fetched the needed content, scrolled through them and nothing really happened. The issue showed up just when we rotated the emulator to change screen orientation, after few seconds, LeakCanary reported a memory leak, followed by a dump of our app&rsquo;s heap. LeakCanary displays the heap in an optimized way so it&rsquo;s easier to find which dominant object is still referencing an object that needs to be GC&rsquo;d.</p><h4 id="2-enabled-profiling-to-monitor-memory-activities">2. Enabled Profiling To Monitor Memory Activities</h4><p>Once we have detected a memory leak in our app, we enabled Memory Monitor to see the allocation and deallocations of memories in our apps. Also we forced excessive GC to see which objects are GC&rsquo;d or not.</p><h4 id="3-dumped-java-heap-and-analyzed-the-trace">3. Dumped Java Heap And Analyzed The Trace.</h4><p>After we have run the profiler for a while, we took a heap dump of it. Using the inbuilt <a href="https://developer.android.com/studio/profile/investigate-ram.html">HPROF Viewer</a> in Android studio, we&rsquo;ere able to analyze the trace for all possible memory leaks in the app. Indeed after analyzing it, we had one issue of memory leak. We were able to jump into the source code to see which code is causing the issue.</p><h4 id="4-located-defected-code">4. Located Defected Code</h4><p>This leaks an Activity.</p><pre class="prettyprint linenums"><code class="language-java">public class Launcher {
    // This will be strongly held by the instance of the Launcher class.
    private Activity mActivity;

    @Inject
    public Launcher(Activity activity) {
        mActivity = activity;
    }

    public void launchReviewList(Context context, Long movieId) {
        context.startActivity(ListReviewsActivity.getIntent(context, movieId));
    }
    
    // This is bad code
    public void launchMovieDetails(FragmentActivity activity, Long movieId, View view) {
        ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(
                // The context of the activity
                activity,
                Pair.create(view, activity.getString(R.string.transition_movie_details)),
                Pair.create(view, activity.getString(R.string.transition_movie_details_background))
        );
        ActivityCompat.startActivity(activity, DetailMovieActivity.getIntent(mActivity, movieId),
                options.toBundle());
    }

    public void launchReminders(Context context) {
        context.startActivity(ListRemindersActivity.getIntent(context));
    }
}

</code></pre><p>The dominant object, <code>mLauncher</code> was holding on to the instance of the activity class.</p><pre class="prettyprint linenums"><code class="language-java">
public class ListMovieFragment extends BaseRecyclerViewFragment&lt;MovieModel, MovieAdapter&gt; implements
        MovieListView, RecyclerViewItemTouchListenerAdapter.RecyclerViewOnItemClickListener,
        OnLoadMoreListener, SwipeRefreshLayout.OnRefreshListener {

    @BindView(R.id.loading_list)
    ProgressBar mProgressBar;

    @BindView(android.R.id.empty)
    View mEmptyView;

    @Inject
    ListMoviePresenter mListMoviePresenter;

    @Inject
    Launcher mLauncher;

    private boolean mIsPaginating;

    private boolean isFromInternet;

    public ListMovieFragment() {
        super(MovieAdapter.class, R.layout.fragment_movie_list, 0);
    }
    ...
}
</code></pre><p>An instance of <code>Launcher</code> class, <code>mLauncher</code> is declared in the <code>ListMovieFragment</code> class and it&rsquo;s referencing an instance of the <code>MainActivity</code> which is declared in the <code>Launcher</code> class as <code>mActivity</code>. Because the fragment class still exist after the main activity hosting it is destroyed.</p><h4 id="5-refactored-defected-code-to-eliminate-the-issue">5. Refactored Defected Code To Eliminate The Issue</h4><pre class="prettyprint linenums"><code class="language-java">
public class Launcher {

    @Inject
    public Launcher() {
    }

    public void launchReviewList(Context context, Long movieId) {
        context.startActivity(ListReviewsActivity.getIntent(context, movieId));
    }

    public void launchMovieDetails(Activity activity, Long movieId, View view) {
        ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(
                // The context of the activity
                activity,
                Pair.create(view, activity.getString(R.string.transition_movie_details)),
                Pair.create(view, activity.getString(R.string.transition_movie_details_background))
        );
        ActivityCompat.startActivity(activity, DetailMovieActivity.getIntent(activity, movieId),
                options.toBundle());
    }

    public void launchReminders(Context context) {
        context.startActivity(ListRemindersActivity.getIntent(context));
    }
}

</code></pre><p>We removed the global instance of Activity, <code>mActivity</code> and instead passed it as a parameter to the method that needed it. This way it can be <code>GC'd</code> easily as there is no strong hold of it anymore.</p><h3 id="conclusion">Conclusion</h3><p>If you&rsquo;re curious about memory leaks in general and ways to avoid them, you can read these great articles belows.</p><ol><li><a href="http://blog.nimbledroid.com/2016/09/06/stop-memory-leaks.html">Eight Ways Your Android App Can STOP Leaking memory</a></li><li><a href="https://developer.android.com/studio/profile/am-memory.html">Memory Monitor</a></li><li><a href="https://developer.android.com/studio/profile/am-hprof.html#hprof-diving">HPROF Viewer and Analyzer</a></li><li><a href="https://developer.android.com/studio/profile/investigate-ram.html">Investigating Your RAM Usage</a></li><li><a href="https://www.youtube.com/watch?v=mU1VcKx8Wzw">Detect all memory leaks with LeakCanary! - Youtube Link</a></li></ol></div></div><div class="row"><div class="p-l-1"><ul class="list-inline"><li class="list-inline-item"><span class="pink-text"><i class="fa fa-clock-o"></i> <time datetime="2016-09-27T11:34:07&#43;09:00" itemprop="datePublished">September 27, 2016</time></span></li><li class="list-inline-item"><a class="btn btn-primary tweet-this" href="https://twitter.com/share" title="Tweet this"><i class="fa fa-twitter"></i> Tweet</a></li></ul></div></div><div class="row"><div class="col-sm-2"><a class="btn btn-danger waves-effect waves-light" href="https://addhen.github.io/afam/calendar/"><i class="fa fa-fw fa-long-arrow-left"></i></a></div><div class="col-sm-2 offset-md-8"><a class="btn btn-danger waves-effect waves-light pull-right" href="https://addhen.github.io/afam/news/persisting-with-cupboard/"><i class="fa fa-fw fa-long-arrow-right"></i></a></div></div><div class="row"><div class="p-l-1"><div id="disqus_thread"></div><script async type="text/javascript">var disqus_shortname = 'afam';
    
     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></div></div></div></div></div><footer class="page-footer rgba-black-lighter center-on-small-only"><div class="footer-copyright text-xs-center rgba-black-lighter"><div class="container"><ul class="list-inline"><li class="list-inline-item">&copy; 2016 &middot; AFAM <span class="powered-by">&middot; developed by <a href="http://www.addhen.com" rel="nofollow">addhen</a></span></li></ul></div></div></footer><script type="text/javascript" src="https://addhen.github.io/afam/js/jquery-2.2.3.min.js" defer="defer"></script><script type="text/javascript" src="https://addhen.github.io/afam/js/tether.min.js" defer="defer"></script><script type="text/javascript" src="https://addhen.github.io/afam/js/bootstrap.min.js" defer="defer"></script><script type="text/javascript" src="https://addhen.github.io/afam/js/jquery.easing-1.3.min.js" defer="defer"></script><script type="text/javascript" src="https://addhen.github.io/afam/js/mdb.min.js" defer="defer"></script><script type="text/javascript" src="https://addhen.github.io/afam/js/jqBootstrapValidation-1.3.7.min.js" defer="defer"></script><script type="text/javascript" src="https://www.google.com/recaptcha/api.js" async defer="defer"></script><script type="text/javascript" src="https://addhen.github.io/afam/js/site-8b7d768f98.min.js" defer="defer"></script><script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?autoload=true&skin=sons-of-obsidian" async defer="defer"></script><script async>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-XXXXXXXX-X', 'auto');
  ga('send', 'pageview');</script></body></html>